{
  "name": "waiter",
  "description": "A simple way to wait for multiple asynchronous calls to return",
  "version": "0.1.1",
  "homepage": "https://github.com/marcello3d/node-waiter",
  "repository": {
    "type": "git",
    "url": "git://github.com/marcello3d/node-waiter.git"
  },
  "author": {
    "name": "Marcello BastÃ©a-Forte",
    "email": "marcello@cellosoft.com",
    "url": "http://marcello.cellosoft.com/"
  },
  "main": "waiter.js",
  "keywords": [
    "async",
    "parallel",
    "flow",
    "asynchronous",
    "flow-control",
    "parallel"
  ],
  "engines": {
    "node": ">=0.4.0"
  },
  "readme": "node-waiter\n===========\nA simple way to wait for multiple asynchronous calls to return in Node.js.\n\nIntroduction\n------------\nJust a little utility class I wrote for dealing with parallel code. It lets you spin off a bunch of asynchronous\noperations and wait for them to finish.\n\nWaiter is similar to other projects like [Step][1], [async][2], and [Seq][3], but with a focus on parallel operations\nthat return values.\n\nExamples\n--------\n\nRead three files asynchronously.\n\n    var waiter = new Waiter\n    var aFile = waiter(),\n        bFile = waiter(),\n        cFile = waiter()\n    fs.readFile('a.txt', aFile)\n    fs.readFile('b.txt', bFile)\n    fs.readFile('c.txt', cFile)\n    // wait for them to finish\n    waiter.waitForAll(function(error) {\n        if (error) {\n            // inspect individual errors in aFile.error, bFile.error, and cFile.error\n            throw \"oh no!\"\n        }\n        // do something with aFile.value, bFile.value, and cFile.value\n    })\n\nYou can call waiter() as many times as you want --- but call them all before calling waitForAll!\n\n    var files = [ ... ]\n    var waiter = new Waiter\n\n    var filesContent = files.map(function(file) {\n        // Alternative syntax, pass a function into waiter(), and get the callback as an argument\n        return waiter(function(done) {\n            fs.readFile(file,done)\n        })\n    })\n    waiter.waitForAll(function(error) {\n        // do something with error or fileContents[x].value\n    }, 2000) // optional timeout parameter\n\n\nDon't care about the values? You don't have to store the result of waiter():\n\n    var waiter = new Waiter\n    fs.writeFile('a.txt', 'hello a!', waiter())\n    fs.writeFile('b.txt', 'hello b!', waiter())\n    fs.writeFile('c.txt', 'hello c!', waiter())\n    waiter.waitForAll(function(error) {\n        if (error) {\n            console.error(\"Oh no!\", error)\n        } else {\n            // all files have been written successfully!\n        }\n    })\n\nAlternative syntax if you don't care about the values:\n\n    new Waiter(\n        function(done) {\n            fs.writeFile('a.txt', 'hello a!', done)\n        },\n        function(done) {\n            fs.writeFile('b.txt', 'hello b!', done)\n        }\n    ).waitForAll(function(error) {\n        // same old...\n    })\n\nLicense\n-------\nWaiter is open source software under the [zlib license][1].\n\n[1]: https://github.com/creationix/step\n[2]: https://github.com/caolan/async\n[3]: https://github.com/substack/node-seq\n[4]: https://github.com/marcello3d/node-mongolian/blob/master/LICENSE",
  "_id": "waiter@0.1.1",
  "dist": {
    "shasum": "673f1c1138734be67d60181e5562f25a64bdc25b"
  },
  "_from": "waiter@0.1.1"
}
